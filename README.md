# lec 1+2

## c++ vs. java
* java takes care of memory management and pointers
* java has libraries and community support

| java           | c++            |
| :------------- | :------------- |
| memory-secured | memory issues  |
| OOD            | OOD            |

## java 101
| data type      | size/behaviour |
| :------------- | :------------- |
| boolean        | T/F            |
| char           | 'a'            |
| byte           | 8-bit          |
| short          | 16-bit         |
| int            | 32-bit         |
| long           | 64-bit         |
| float          | 32-bit         |
| double         | 64-bit         |

```java
int[] numbers = new int[10];
```
* **explicit array**: fixed size array; vs dynamic collections

## embedded systems
* devices used to control, monitor, or assist operation of equipment, machinery, or plant
* types: (simple) embedded system, (complex) embedded computer system

### sensors and actuators
* in an embedded system, sensors --> CPU --> actuators
* sensor readings are continuous and analog
* computers are discrete-time and digital
  * so report discrete values at given times from the sensors
* **analog-to-digital-converter (ADC)**: part of the codec; coverts continuous-time analog signal to discrete-time digital signal
* **actuators**: convert output from computer system into some effect on environment (Digitial to Analog Converter)

### Project Management Terminology
* Functional Requirements: "What the software should do"
* Non-Functional Requirement: "How the software should feel like"
* Constraints: "Without this, software projet would FAIL"
* Specifications: "How do to do" (underlying engineering tehcnical details for requirements and constraints

# lec 3

## event driven programming
* the program needs to
  * handle incoming signals from sensors
  * generate desired signals to actuators
  * coordinate diff events from diff hardware pieces
  * loop indefinitely until user shuts down system

## traditional method (a comparison)
* sensor > flag > handler > actuator

## event-driven model
* sensor > event manager > handler > actuator

### operating system
* everything is already automated
* **sensor event manager**: part of the OS that checks flags raised by sensors and acts when necessary
* **event handler**: action sequence that OS does upon events
  * every event is distinct course of actions
  * every sensor needs a Handler that programmer defines
* Android OS is standardized OS:
  * standardized hardware and software APIs
  * manage hardware platform
  * implements Sensor Event Manager to take care of sensor-actuator interactions
* **event manager**: standardized loop for event checking, standardized procedures for interacting with sensor events/data delivery, event: handler lookup table

# lec 4: java IO & exceptions

## exceptions
* **exception**: signal of runtime execution error; an *event* that indicates something is wrong during execution, and computer doesn't know what to do
* java ```throws``` errors
* **two sources**: automatically generated by JRE, explicitly generated by programmer

### exception handling
* handle: take actions to deal with Exception
* exception handling hierarchy (call stack)
  * local exception handler > exception handlers in the invoker/caller > handlers in higher invokers/callers > handlers in main method >> execution stops + error message on screen
* ```try - catch``` block; can also have multiple catch blocks
* ```finally``` block: always executes after try-catch block
  * purpose: avoid accidental bypass of mandatory cleanup code
---
* sometimes don't want to handle the error
  1. try-catch block is system-resource demanding
  2. most exceptions can be prevented with code review and test cases
  3. exceptions that matter are runtime-determined user/machine mistakes that are recoverable
  4. sometimes, just force invoker of method to handle exception > *"pass the hot potato"*
---
* declaring pass on exceptions: handling the ```IOException``` is the responsibility of the invoker of ```writeList()```
```java
public void writeList() throws IOException
```

## java/android file I/O
* java. I/O is modeled as a *stream*
  * **stream**: sequence of data; used to read data (input stream) or write data (output stream)
  * the superclasses: ```InputStream``` and ```OutputStream```

### read and write
* file streams are closed in ```finally``` block
* very bad efficiency --> ```in.read()``` accesses hard disk one character (one byte) at a time
  * solution: reduce disk access

```java
public class CopyFile {
  public static void main(String[] args) throws IOException {
    FileInputStream in = null;
    FileOutputStream out = null;

    try {
      in = new FileInputStream("input.txt");
      out = new FileOutputStream("output.txt");
      int c;

      while ((c = in.read()) != -1) {
        out.write(c);
      }
    } finally {
      if (in != null) {
        in.close();
      }
      if (out != null) {
        out.close();
      }
    }
  }
}
```

### buffered r/w

#### BufferedReader
* reconfigurable size (usu multiples of 1024 bytes)
* given file name, BufferedReader reads bytes from the file and store in buffer until buffer is full
* ```readLine()``` method requests all data before seeing ```\n```
  * data can be in the buffer already
  * BufferedReader checks its own buffer, provides data from buffer if requested data is found (disk access is avoided)
  * if BufferedReader reaches end of buffer before finding requested data, then disk access to fill up buffer with next chunk of data

* significantly reduces number of disk access

#### BufferedWriter
* reconfigurable size
* outputs from ```println()``` is kept in buffer, disk write only happens when buffer is full
* program crash > disappearance of some expected output data, because data in buffer may not have been written to disk
* if program catches Exception (leading to program crash), ```flush()``` can be called to force buffer to output data before it's full
* closing the stream also flushes the buffer

```java
public class CopyFile {
  public static void main(String[] args) throws IOException {
    BufferedReader inputStream = null;
    PrintWriter outputStream = null;

    try {
      inputStream = new BufferedReader(new FileReader("input.txt"));
      outputStream = new PrintWriter(new FileWriter("output.txt"));

      String l;
      while ((l = inputStream.readLine()) != null) {
        outputStream.println(l);
      }
    } finally {
      if (inputStream != null) {
        inputStream.close();
      }
      if (outputStream != null) {
        outputStream.close();
      }
    }
  }
}
```

### android storage media structure
* **internal storage**: hidden in OS; cannot access files stored in there, unless within program that creates the files
* **default external storage**: located under ```Android/data``` folder
  * use ```getExternalFileDir(FOLDER_NAME)``` to obtain absolute path
* **additional external storages**: SD cards, SIM cards, etc. need to configure permission parameters in ```Manifest.xml``` to access from within app

### file
* ```FileReader``` and ```FileWriter``` are grouped under data type *file*

```java
File file = new File(getDefaultFileDir(FOLDER_NAME), FILE_NAME);
PrintWriter pwr = new PrintWriter(file);
```

# lec 5: finite state machine
* events are random incidents
* system has internal states that can its response to the same event
* environmental stimulants + user input > finite state machine (internal state feedback) > machine output

| external       | internal       |
| :------------- | :------------- |
| external stimulants       | events       |
| internal stimulants       | system states       |
| output       | combinatorial result of external and internal stimulants       |

## UML state diagram
* graphical representation of FSM
* used by embedded hardware and software designers
* generated from functional description of system
* used as reference to create software/hardware version of FSM implementation
* has following components:

### structure of State Box:
| State Name |
| :-------: |
| Activities ( do/ _activity_ )|

### Start Point:
* indicates initial state of FSM and prepaartion actions to set up initial state

### State Transition:
> Event [Guard] / Actions
* Event: event that triggers state transition
* Guard: condition that allows for state transition after event occurs
* Action `do/ or /`: actions taken after state transition to prepare for next state

*look at slides from lec5 for more UML stuff*

## Superstate: Abstract encompassent of part of FSM states as one generalized state
* simplifies complex diagrams

# lec 6: polling, interrupt, timers

## events and handlers
* **events**: excitations to a system
  * hardware excitations: sensor reading changes
  * software excitations: timer expires
  * in Android: *notification* of change of state of system
* **handlers/listeners**: response of system to the excitation
  * sensor event handlers, timer handlers, button event listeners
* events and its data gets passed to Android's Sensor Event Manager >> respective event listeners
* event driven: reactive, not proactive
  * sensor > event manager > handler > actuator

### callback
* **callback methods (classes)**: system/users/environments decides what happens, not the program
  * *inversion of control*
* allows for asynchronous, non-blocking program exec.
* with callback methods, *time-consuming tasks (TCT)* won't delay program because it's running in parallel
* concurrent programming uses power of multi-core CPU/similar processor structures
* callbacks are facilitating tool of program concurrency


## polling & interrupt
* **modern embedded systems**: each sensor/actuator has >= 1 micro-controller within
  * used for sensor monitoring/actuator control; communication with CPU
* **polling (passive synchronization)**: watches parameter for change at any given time
* **interrupt (active synchronization)**: raises attention when parameter is confirmed to be changed

### polling
* CPU takes role of checking devices status
* *passive synchronization*; devices passively report status changes
* programmers decide how much system allocates to checking device status

| polling "intensity level" | description     |
| :------------- | :------------- |
| tight polling       | entire system resource dedicated to monitoring changes        |
| periodic polling       | using a fixed timer period, use system resources to obtain changes       |
| occasional polling       | obtain changes when system resources are free       |

* every Event Listener thread has a *tight-polling loop* used to monitor sensor events

### interrupt
* hardware version of Event-Handler setup
* *active synchronization*; device actively reporting changes to CPU
* devices setup for interrupts are connected to CPUs (*interrupt request (IRQ) line*)
* programmer creates program to take care of interrupt when specific IRQ is raised >> *interrupt service routine (ISR)* or *interrupt handler*
* IRQ >> CPU takes an action

## timer
* events are random occurrences
* event listeners are parallel threads to main program (concurrent programming)
* **timer**: periodic event generator
  * parallel thread to main program, own configurable expiry time, can be one-shot timer or recurring, has Timer Handler
  * tasks are put in Timer Handler for repeating timer, so when TimerExpire event happens, it gets fired up

### applications of timers
* interval timer: period task performer (period polling)
* watchdog timer: system deadlock prevention before TCT that could crash
  * *one-shot timer* with duration longer than estimated max process time of TCT so that if TCT completes before timer, TCT probably got stuck
  * TimerExpire event >> TimerHandler >> TCT forced to terminate in the Handler
  
### Example:
```
Timer timer = new Timer();
TimerTask tast = new TimerTask() {
 @Override
 public void run() {
  System.out.println("hello world");
 }
}

// schedule(task, delay, period);
timer.schedule(task, 500, 500);
```

# lec 7: android, xml, version control

## android application structure
* **activity**: full-screen window that users can interact with
* **widgets (views)**: interactive items that allow for user interactions
* **single-activity app**: app with one full-screen interface
* **multi-activity app**: app with multiple full-screen interfaces, functionally dependent on each other
* **activity cross-dependency**: activities in one app may have dependency on activities in another app
* **task (activity call stack)**: android OS has a task stack (prevents disruption to functional dependency)
* **multi-tasking**: switching between Tasks; switch activity stacks between foreground activity and background activity

## android lifecycle
* events take place between state transitions


* onCreate(): activity initialized, ready in memory
* onStart(): moved to foreground, active, initial state
* onResume(): foreground active, running state
* onPause(): background inactive, data persistent
* onStop(): background inactive, data destroyed
* onDestroy(): activity removed from memory

## bundle: saving and restoring states
* to conserve data: need a *Bundle* and helper method *onSaveInstanceState()*
  * called in onDestroy() right before activity is destroyed
  * everything in the bundle is available in onCreate() when the activity is brought back
* *bundle* is a key-value map
* *onSaveInstanceState()* is a method in AppCompatActivity class
* use ```putString(String key, String value)```
```java
class MainActivity ... {
 String color;
 
 @Override
 potected void onSaveInstanceState(Bundle b) {
  super.onSaveInstanceState(b);
  b.putString("color", color);
 }
}
```
* to get data:
```java
protected void onCreate(Bundle savedInstanceState) {
    if (savedInstanceState != null) {
      data = savedInstanceState.getString("key");
    }
}
```

## eXtensible markup language (xml)
* a *markup language*; structured document format (define appearance and properties of contents of document)
* no intrinsic meaning
* XML documents are displayed to users through *XML parser*

```xml
<?xml version="1.0" encoding="utf-8"?>
stuff
```

## accelerometers/gyroscopes
* micro-electro-mechanical (MEM) device that senses ambient mechanical movements
  * transitional acceleration, torsional acceleration
* how does it work: relative positioning of "proof mass" to surrounding wall under acceleration (mass inertia)
* **signal analysis**: software noise minimization and main signal recognition

# lec 8: oop

## advantages
* inheritance, polymorphism, interface/abstract classes

## concrete class: object encapsulation
* class name, fields, methods (member functions, constructor, destructor)
* class instantiation: dynamic memory allocation, just need keyword ```new```
* all *non-static* fields and methods are accessible after the class is instantiated
* ```static``` fields and methods are pre-allocated in memory with unique memory address reference before execution so they are readily accessible without creating instance of class

### advantages
* **data encapsulation**: fields and functions can be intended just for internal operations of class, and be only accessible in the class
  * visibility: public, private, protected
  * uniqueness: final, static
* **macro-management**: class instantiation allows multiple instances of the class without micromanagement in memory allocation

## UML class diagram

### basic class block
* 3 column:
  1. class name (bold)
  2. attributes/fields : data type
  3. operations (constructors, methods, etc) : return type
* visibility modifier (put in front of field/method): public (+), private (-), protected (#)
* uniqueness modifier: static (underline), final (capitalization)
* destructor/package (~)
* range of values (..)
* separator of items in set (,)
* *in* in front of input parameters
* *out* in front of output parameters

## object derivation
* ```extends```: facilitates inheritance
* ```super```: reference instance of super-class
* ```super()```: calls constructor of super-class
* ```this```: reference instance of the child-class

## Concept Review: OOD
### Class Comparison
|        | Concrete Class | Abstract Class      | Interface                        |
|:-------|:---------------|:--------------------|:---------------------------------|
| Fields | No restriction | Public or protected | Public default, Constant default |
| Methods| must be implemented | unimplemented are abstract | signature only |
| Declaration | `class` | `abstract class` | `interface` |
|Instantiability| Y | N | N |
|Inheritance | extends | extends | implements |
|multiple inheritance| N | N | Y |
|other | has constructors and destructors | can contain all concrete methods; no constructor | no scpoe modifier; uniqueness modifier required|

### Modifiers
| Modifier | Interface | Class | Nested Class | Field | Method |
|:---------|-----------|-------|--------------|-------|--------|
| public   | Accessible from any class                         |
| private  | Accessible only from the `this`                   |
| protected| Accessible from within package (`this` and subclasses) |
| none     | Accessible from any class within same package (BAD)|
| abstract | N/A       | Contains at least one abstract method, no instantiation | N/A | implementation not defined, only signature and return type declared |
| final    | N/A       | Cannot be subclassed | Value cannot change | Cannot be overridden |
| static   | N/A       | N/A   | Not inner class | Exactly one instance for all objects | Exactly one instance for all objects |

# Post-midterm lectures

## Testing:
### Testing Levels:
   1. smoke test
     * adding code until it fails
   2. integration test
     * testing the entire thing
   3. System Test
     * testing entire system
   4. Stress Test
     * execute software over extended period of time with long and cyclic test plans
   5. Regression Test
     * testing after new updates
 
### unit test:
* double click class to test and create new test.
* additional procedure on slides

```java
class testClass {
 @Test
 public void computeTest() throws Exception {
  assertEquals("Test Case: inputs", expectedOutput, otherClass.testFunction(inputs), 
 }
}
```

#Test Suite Implementation:
## Test Fixtures (Annotations)
* `@Before`: Setting up tst configurations before every `@Test`
* `@After`: Release the resources after every `@Test`
```java
public class Test {
 Test instance;
 
 @Before
 public void setUp() {
  System.out.println("Test setup");
  instance = new Test(1);
 }
 
 @Test
 public void testOne() {
  assertEquals("Case 1, 0", 1, instance.computeTrig(1,0), 0.001);
 }
 
 @After
 public void tearDown() {
  instance.printEndMesssage();
  instance = null;
 }
 
 @BeforeTest
 @AfterTest
 // static methods before run before and after entire test suite
 
 // expecting exceptions
 @Test(expected = IllegalArgumentException.class)
 publlic void test() {
  // do something
 }
}
```
```java
public clss Topic2TestSuite {
 
 @Before
 public void settingUp() {
  Topic1Class classUnderTest = new Topic1Class();
 }
 
 @Test
 public void normalTest() throws Exception {
  assertEquals("<Test Name>", expectedOutput, class.functiontoTest(input1, input2), (float) levelOfAccuracy);
 }
 
 @Test (expected = IllegalArgumentException.class)
 public void exceptionTestCases() throws Exception {
  // does not need assertEquals since it expects an exception and will fail if the exception does not throw
  class.functionToTest(improperInput1, improperInput2);
 }
}
```

# Multithreading and Concurrency:
## Multithreading:
* CPU not always executing code; when idling CPU executes *NOP* command
  * For TCTs, leaves program waits and leaves CPU *NOP*ing for inefficient time
### Virtual Parallel Tasking: 
* Maximizing usage of CPU to allow max number of processes / programs to appear to run in parallel
### Thread Scheduling:
* Process of allocating CPU processing time to different threads. 
### Process:
* executable program
* memory locations allocated or the program and its needed heap & stack
### Thread: Sequence of Commands
* Thread Scheduling: non-preemptive scheduling given 1 CPU core: look at slides
* Pre-emptive scheduling example:
  * Given Priority level 1 > 2 > 3
  * Thread A: Periodic Task with Deadline
  * Thread B: TCT with long wait time
  * Thread C: Deadline at 98 ms.
* eg. File I/O vs. LineGraphView.
### Time Coallescing

# Sequence Diagrams
## Multithread System Analysis:
### Timing Analysis Table:
* eg. Instance arrangement: Instances on the left invoke instances on the right.
  * dotted line to represent when the thread gets created and removed.
  * Gate indicates the start of the process
  * Indicates listener that instanciates instance on the right: solid lines to ensure synchronous messaging (return call OK)
